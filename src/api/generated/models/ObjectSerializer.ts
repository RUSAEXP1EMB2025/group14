export * from '../models/AirconSettingsResponse';
export * from '../models/ApplianceModelAndParam';
export * from '../models/ApplianceModelAndParamModel';
export * from '../models/ApplianceModelAndParamParams';
export * from '../models/ApplianceResponse';
export * from '../models/ApplianceResponseAircon';
export * from '../models/ApplianceResponseAirconRange';
export * from '../models/ApplianceResponseAirconRangeModesValue';
export * from '../models/ApplianceResponseAirconSmartEcoMode';
export * from '../models/ApplianceResponseBle';
export * from '../models/ApplianceResponseBleMacrosValue';
export * from '../models/ApplianceResponseBleSesame';
export * from '../models/ApplianceResponseDevice';
export * from '../models/ApplianceResponseEchonetlite';
export * from '../models/ApplianceResponseEchonetliteGetPropertiesValue';
export * from '../models/ApplianceResponseEchonetliteLocalize';
export * from '../models/ApplianceResponseEchonetliteLocalizePropertiesValue';
export * from '../models/ApplianceResponseEchonetliteLocalizePropertiesValueEnumValue';
export * from '../models/ApplianceResponseLight';
export * from '../models/ApplianceResponseLightButtonsInner';
export * from '../models/ApplianceResponseLightProjector';
export * from '../models/ApplianceResponseLightProjectorLayout';
export * from '../models/ApplianceResponseLightProjectorLayoutTemplatesInner';
export * from '../models/ApplianceResponseLightState';
export * from '../models/ApplianceResponseMorninPlus';
export * from '../models/ApplianceResponseMorninPlusDevicesInner';
export * from '../models/ApplianceResponseQrioLock';
export * from '../models/ApplianceResponseQrioLockDevice';
export * from '../models/ApplianceResponseSettings';
export * from '../models/ApplianceResponseSignalsInner';
export * from '../models/ApplianceResponseSmartMeter';
export * from '../models/ApplianceResponseSmartMeterEchonetlitePropertiesInner';
export * from '../models/ApplianceResponseTv';
export * from '../models/ApplianceResponseTvLayoutInner';
export * from '../models/ApplianceResponseTvState';
export * from '../models/BLEPrivateMacroResponse';
export * from '../models/DeviceResponse';
export * from '../models/DeviceResponseNewestEventsValue';
export * from '../models/DeviceResponseUsersInner';
export * from '../models/EchonetLiteApplianceResponse';
export * from '../models/EchonetLiteApplianceResponseAppliancesInner';
export * from '../models/EchonetLiteApplianceResponseAppliancesInnerPropertiesInner';
export * from '../models/HomeInvite';
export * from '../models/HomeInviteHome';
export * from '../models/HomeInviteUser';
export * from '../models/HomeResponse';
export * from '../models/HomeResponseLocation';
export * from '../models/HomeResponseTown';
export * from '../models/HomeResponseUsersInner';
export * from '../models/LightState';
export * from '../models/Signal';
export * from '../models/TVState';
export * from '../models/Template';
export * from '../models/UserAndRole';
export * from '../models/UserResponse';
export * from '../models/UserResponseUpdatedPrivacyPolicy';
export * from '../models/UserResponseUpdatedPrivacyPolicyLinksValue';

import { AirconSettingsResponse } from '../models/AirconSettingsResponse';
import { ApplianceModelAndParam } from '../models/ApplianceModelAndParam';
import { ApplianceModelAndParamModel } from '../models/ApplianceModelAndParamModel';
import { ApplianceModelAndParamParams } from '../models/ApplianceModelAndParamParams';
import { ApplianceResponse } from '../models/ApplianceResponse';
import { ApplianceResponseAircon } from '../models/ApplianceResponseAircon';
import { ApplianceResponseAirconRange } from '../models/ApplianceResponseAirconRange';
import { ApplianceResponseAirconRangeModesValue } from '../models/ApplianceResponseAirconRangeModesValue';
import { ApplianceResponseAirconSmartEcoMode } from '../models/ApplianceResponseAirconSmartEcoMode';
import { ApplianceResponseBle } from '../models/ApplianceResponseBle';
import { ApplianceResponseBleMacrosValue } from '../models/ApplianceResponseBleMacrosValue';
import { ApplianceResponseBleSesame } from '../models/ApplianceResponseBleSesame';
import { ApplianceResponseDevice } from '../models/ApplianceResponseDevice';
import { ApplianceResponseEchonetlite } from '../models/ApplianceResponseEchonetlite';
import { ApplianceResponseEchonetliteGetPropertiesValue } from '../models/ApplianceResponseEchonetliteGetPropertiesValue';
import { ApplianceResponseEchonetliteLocalize } from '../models/ApplianceResponseEchonetliteLocalize';
import { ApplianceResponseEchonetliteLocalizePropertiesValue } from '../models/ApplianceResponseEchonetliteLocalizePropertiesValue';
import { ApplianceResponseEchonetliteLocalizePropertiesValueEnumValue } from '../models/ApplianceResponseEchonetliteLocalizePropertiesValueEnumValue';
import { ApplianceResponseLight } from '../models/ApplianceResponseLight';
import { ApplianceResponseLightButtonsInner } from '../models/ApplianceResponseLightButtonsInner';
import { ApplianceResponseLightProjector } from '../models/ApplianceResponseLightProjector';
import { ApplianceResponseLightProjectorLayout } from '../models/ApplianceResponseLightProjectorLayout';
import { ApplianceResponseLightProjectorLayoutTemplatesInner } from '../models/ApplianceResponseLightProjectorLayoutTemplatesInner';
import { ApplianceResponseLightState } from '../models/ApplianceResponseLightState';
import { ApplianceResponseMorninPlus } from '../models/ApplianceResponseMorninPlus';
import { ApplianceResponseMorninPlusDevicesInner } from '../models/ApplianceResponseMorninPlusDevicesInner';
import { ApplianceResponseQrioLock } from '../models/ApplianceResponseQrioLock';
import { ApplianceResponseQrioLockDevice } from '../models/ApplianceResponseQrioLockDevice';
import { ApplianceResponseSettings } from '../models/ApplianceResponseSettings';
import { ApplianceResponseSignalsInner } from '../models/ApplianceResponseSignalsInner';
import { ApplianceResponseSmartMeter } from '../models/ApplianceResponseSmartMeter';
import { ApplianceResponseSmartMeterEchonetlitePropertiesInner } from '../models/ApplianceResponseSmartMeterEchonetlitePropertiesInner';
import { ApplianceResponseTv } from '../models/ApplianceResponseTv';
import { ApplianceResponseTvLayoutInner } from '../models/ApplianceResponseTvLayoutInner';
import { ApplianceResponseTvState } from '../models/ApplianceResponseTvState';
import { BLEPrivateMacroResponse } from '../models/BLEPrivateMacroResponse';
import { DeviceResponse } from '../models/DeviceResponse';
import { DeviceResponseNewestEventsValue } from '../models/DeviceResponseNewestEventsValue';
import { DeviceResponseUsersInner } from '../models/DeviceResponseUsersInner';
import { EchonetLiteApplianceResponse } from '../models/EchonetLiteApplianceResponse';
import { EchonetLiteApplianceResponseAppliancesInner } from '../models/EchonetLiteApplianceResponseAppliancesInner';
import { EchonetLiteApplianceResponseAppliancesInnerPropertiesInner } from '../models/EchonetLiteApplianceResponseAppliancesInnerPropertiesInner';
import { HomeInvite } from '../models/HomeInvite';
import { HomeInviteHome } from '../models/HomeInviteHome';
import { HomeInviteUser } from '../models/HomeInviteUser';
import { HomeResponse } from '../models/HomeResponse';
import { HomeResponseLocation } from '../models/HomeResponseLocation';
import { HomeResponseTown } from '../models/HomeResponseTown';
import { HomeResponseUsersInner } from '../models/HomeResponseUsersInner';
import { LightState } from '../models/LightState';
import { Signal } from '../models/Signal';
import { TVState } from '../models/TVState';
import { Template } from '../models/Template';
import { UserAndRole } from '../models/UserAndRole';
import { UserResponse } from '../models/UserResponse';
import { UserResponseUpdatedPrivacyPolicy } from '../models/UserResponseUpdatedPrivacyPolicy';
import { UserResponseUpdatedPrivacyPolicyLinksValue } from '../models/UserResponseUpdatedPrivacyPolicyLinksValue';

/* tslint:disable:no-unused-variable */
let primitives = ['string', 'boolean', 'double', 'integer', 'long', 'float', 'number', 'any'];

let enumsMap: Set<string> = new Set<string>([]);

let typeMap: { [index: string]: any } = {
  AirconSettingsResponse: AirconSettingsResponse,
  ApplianceModelAndParam: ApplianceModelAndParam,
  ApplianceModelAndParamModel: ApplianceModelAndParamModel,
  ApplianceModelAndParamParams: ApplianceModelAndParamParams,
  ApplianceResponse: ApplianceResponse,
  ApplianceResponseAircon: ApplianceResponseAircon,
  ApplianceResponseAirconRange: ApplianceResponseAirconRange,
  ApplianceResponseAirconRangeModesValue: ApplianceResponseAirconRangeModesValue,
  ApplianceResponseAirconSmartEcoMode: ApplianceResponseAirconSmartEcoMode,
  ApplianceResponseBle: ApplianceResponseBle,
  ApplianceResponseBleMacrosValue: ApplianceResponseBleMacrosValue,
  ApplianceResponseBleSesame: ApplianceResponseBleSesame,
  ApplianceResponseDevice: ApplianceResponseDevice,
  ApplianceResponseEchonetlite: ApplianceResponseEchonetlite,
  ApplianceResponseEchonetliteGetPropertiesValue: ApplianceResponseEchonetliteGetPropertiesValue,
  ApplianceResponseEchonetliteLocalize: ApplianceResponseEchonetliteLocalize,
  ApplianceResponseEchonetliteLocalizePropertiesValue:
    ApplianceResponseEchonetliteLocalizePropertiesValue,
  ApplianceResponseEchonetliteLocalizePropertiesValueEnumValue:
    ApplianceResponseEchonetliteLocalizePropertiesValueEnumValue,
  ApplianceResponseLight: ApplianceResponseLight,
  ApplianceResponseLightButtonsInner: ApplianceResponseLightButtonsInner,
  ApplianceResponseLightProjector: ApplianceResponseLightProjector,
  ApplianceResponseLightProjectorLayout: ApplianceResponseLightProjectorLayout,
  ApplianceResponseLightProjectorLayoutTemplatesInner:
    ApplianceResponseLightProjectorLayoutTemplatesInner,
  ApplianceResponseLightState: ApplianceResponseLightState,
  ApplianceResponseMorninPlus: ApplianceResponseMorninPlus,
  ApplianceResponseMorninPlusDevicesInner: ApplianceResponseMorninPlusDevicesInner,
  ApplianceResponseQrioLock: ApplianceResponseQrioLock,
  ApplianceResponseQrioLockDevice: ApplianceResponseQrioLockDevice,
  ApplianceResponseSettings: ApplianceResponseSettings,
  ApplianceResponseSignalsInner: ApplianceResponseSignalsInner,
  ApplianceResponseSmartMeter: ApplianceResponseSmartMeter,
  ApplianceResponseSmartMeterEchonetlitePropertiesInner:
    ApplianceResponseSmartMeterEchonetlitePropertiesInner,
  ApplianceResponseTv: ApplianceResponseTv,
  ApplianceResponseTvLayoutInner: ApplianceResponseTvLayoutInner,
  ApplianceResponseTvState: ApplianceResponseTvState,
  BLEPrivateMacroResponse: BLEPrivateMacroResponse,
  DeviceResponse: DeviceResponse,
  DeviceResponseNewestEventsValue: DeviceResponseNewestEventsValue,
  DeviceResponseUsersInner: DeviceResponseUsersInner,
  EchonetLiteApplianceResponse: EchonetLiteApplianceResponse,
  EchonetLiteApplianceResponseAppliancesInner: EchonetLiteApplianceResponseAppliancesInner,
  EchonetLiteApplianceResponseAppliancesInnerPropertiesInner:
    EchonetLiteApplianceResponseAppliancesInnerPropertiesInner,
  HomeInvite: HomeInvite,
  HomeInviteHome: HomeInviteHome,
  HomeInviteUser: HomeInviteUser,
  HomeResponse: HomeResponse,
  HomeResponseLocation: HomeResponseLocation,
  HomeResponseTown: HomeResponseTown,
  HomeResponseUsersInner: HomeResponseUsersInner,
  LightState: LightState,
  Signal: Signal,
  TVState: TVState,
  Template: Template,
  UserAndRole: UserAndRole,
  UserResponse: UserResponse,
  UserResponseUpdatedPrivacyPolicy: UserResponseUpdatedPrivacyPolicy,
  UserResponseUpdatedPrivacyPolicyLinksValue: UserResponseUpdatedPrivacyPolicyLinksValue
};

type MimeTypeDescriptor = {
  type: string;
  subtype: string;
  subtypeTokens: string[];
};

/**
 * Every mime-type consists of a type, subtype, and optional parameters.
 * The subtype can be composite, including information about the content format.
 * For example: `application/json-patch+json`, `application/merge-patch+json`.
 *
 * This helper transforms a string mime-type into an internal representation.
 * This simplifies the implementation of predicates that in turn define common rules for parsing or stringifying
 * the payload.
 */
const parseMimeType = (mimeType: string): MimeTypeDescriptor => {
  const [type = '', subtype = ''] = mimeType.split('/');
  return {
    type,
    subtype,
    subtypeTokens: subtype.split('+')
  };
};

type MimeTypePredicate = (mimeType: string) => boolean;

// This factory creates a predicate function that checks a string mime-type against defined rules.
const mimeTypePredicateFactory =
  (predicate: (descriptor: MimeTypeDescriptor) => boolean): MimeTypePredicate =>
  mimeType =>
    predicate(parseMimeType(mimeType));

// Use this factory when you need to define a simple predicate based only on type and, if applicable, subtype.
const mimeTypeSimplePredicateFactory = (type: string, subtype?: string): MimeTypePredicate =>
  mimeTypePredicateFactory(descriptor => {
    if (descriptor.type !== type) return false;
    if (subtype != null && descriptor.subtype !== subtype) return false;
    return true;
  });

// Creating a set of named predicates that will help us determine how to handle different mime-types
const isTextLikeMimeType = mimeTypeSimplePredicateFactory('text');
const isJsonMimeType = mimeTypeSimplePredicateFactory('application', 'json');
const isJsonLikeMimeType = mimeTypePredicateFactory(
  descriptor =>
    descriptor.type === 'application' && descriptor.subtypeTokens.some(item => item === 'json')
);
const isOctetStreamMimeType = mimeTypeSimplePredicateFactory('application', 'octet-stream');
const isFormUrlencodedMimeType = mimeTypeSimplePredicateFactory(
  'application',
  'x-www-form-urlencoded'
);

// Defining a list of mime-types in the order of prioritization for handling.
const supportedMimeTypePredicatesWithPriority: MimeTypePredicate[] = [
  isJsonMimeType,
  isJsonLikeMimeType,
  isTextLikeMimeType,
  isOctetStreamMimeType,
  isFormUrlencodedMimeType
];

const nullableSuffix = ' | null';
const optionalSuffix = ' | undefined';
const arrayPrefix = 'Array<';
const arraySuffix = '>';
const mapPrefix = '{ [key: string]: ';
const mapSuffix = '; }';

export class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === 'Date') {
      return expectedType;
    } else {
      if (enumsMap.has(expectedType)) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          var discriminatorType = data[discriminatorProperty];
          let mapping = typeMap[expectedType].mapping;
          if (mapping != undefined && mapping[discriminatorType]) {
            return mapping[discriminatorType]; // use the type given in the discriminator
          } else if (typeMap[discriminatorType]) {
            return discriminatorType;
          } else {
            return expectedType; // discriminator did not map to a type
          }
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string, format: string): any {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.endsWith(nullableSuffix)) {
      let subType: string = type.slice(0, -nullableSuffix.length); // Type | null => Type
      return ObjectSerializer.serialize(data, subType, format);
    } else if (type.endsWith(optionalSuffix)) {
      let subType: string = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
      return ObjectSerializer.serialize(data, subType, format);
    } else if (type.startsWith(arrayPrefix)) {
      let subType: string = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
      let transformedData: any[] = [];
      for (let date of data) {
        transformedData.push(ObjectSerializer.serialize(date, subType, format));
      }
      return transformedData;
    } else if (type.startsWith(mapPrefix)) {
      let subType: string = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
      let transformedData: { [key: string]: any } = {};
      for (let key in data) {
        transformedData[key] = ObjectSerializer.serialize(data[key], subType, format);
      }
      return transformedData;
    } else if (type === 'Date') {
      if (format == 'date') {
        let month = data.getMonth() + 1;
        month = month < 10 ? '0' + month.toString() : month.toString();
        let day = data.getDate();
        day = day < 10 ? '0' + day.toString() : day.toString();

        return data.getFullYear() + '-' + month + '-' + day;
      } else {
        return data.toISOString();
      }
    } else {
      if (enumsMap.has(type)) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // Get the actual type of this object
      type = this.findCorrectType(data, type);

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let attributeType of attributeTypes) {
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type,
          attributeType.format
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string, format: string): any {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.endsWith(nullableSuffix)) {
      let subType: string = type.slice(0, -nullableSuffix.length); // Type | null => Type
      return ObjectSerializer.deserialize(data, subType, format);
    } else if (type.endsWith(optionalSuffix)) {
      let subType: string = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
      return ObjectSerializer.deserialize(data, subType, format);
    } else if (type.startsWith(arrayPrefix)) {
      let subType: string = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
      let transformedData: any[] = [];
      for (let date of data) {
        transformedData.push(ObjectSerializer.deserialize(date, subType, format));
      }
      return transformedData;
    } else if (type.startsWith(mapPrefix)) {
      let subType: string = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
      let transformedData: { [key: string]: any } = {};
      for (let key in data) {
        transformedData[key] = ObjectSerializer.deserialize(data[key], subType, format);
      }
      return transformedData;
    } else if (type === 'Date') {
      return new Date(data);
    } else {
      if (enumsMap.has(type)) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let attributeType of attributeTypes) {
        let value = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type,
          attributeType.format
        );
        if (value !== undefined) {
          instance[attributeType.name] = value;
        }
      }
      return instance;
    }
  }

  /**
   * Normalize media type
   *
   * We currently do not handle any media types attributes, i.e. anything
   * after a semicolon. All content is assumed to be UTF-8 compatible.
   */
  public static normalizeMediaType(mediaType: string | undefined): string | undefined {
    if (mediaType === undefined) {
      return undefined;
    }
    return (mediaType.split(';')[0] ?? '').trim().toLowerCase();
  }

  /**
   * From a list of possible media types, choose the one we can handle best.
   *
   * The order of the given media types does not have any impact on the choice
   * made.
   */
  public static getPreferredMediaType(mediaTypes: Array<string>): string {
    /** According to OAS 3 we should default to json */
    if (mediaTypes.length === 0) {
      return 'application/json';
    }

    const normalMediaTypes = mediaTypes.map(ObjectSerializer.normalizeMediaType);

    for (const predicate of supportedMimeTypePredicatesWithPriority) {
      for (const mediaType of normalMediaTypes) {
        if (mediaType != null && predicate(mediaType)) {
          return mediaType;
        }
      }
    }

    throw new Error('None of the given media types are supported: ' + mediaTypes.join(', '));
  }

  /**
   * Convert data to a string according the given media type
   */
  public static stringify(data: any, mediaType: string): string {
    if (isTextLikeMimeType(mediaType)) {
      return String(data);
    }

    if (isJsonLikeMimeType(mediaType)) {
      return JSON.stringify(data);
    }

    throw new Error(
      'The mediaType ' + mediaType + ' is not supported by ObjectSerializer.stringify.'
    );
  }

  /**
   * Parse data from a string according to the given media type
   */
  public static parse(rawData: string, mediaType: string | undefined) {
    if (mediaType === undefined) {
      throw new Error('Cannot parse content. No Content-Type defined.');
    }

    if (isTextLikeMimeType(mediaType)) {
      return rawData;
    }

    if (isJsonLikeMimeType(mediaType)) {
      return JSON.parse(rawData);
    }

    throw new Error('The mediaType ' + mediaType + ' is not supported by ObjectSerializer.parse.');
  }
}
